---
layout: post
title: Kubernetes for appliation developers
date: 2022-03-08 18:10:00 + 0900
categories: Kubernetes
ref: kubernetes, container, docker
---

# Kubernetes for application developers(LFD459)

## 1. 쿠버네티스 구조

### 1-1. 쿠버네티스란?
  - 컨테이너를 데스크탑에서 실행하는 것은 쉽다. 하지만 여러 호스트에 다운타임 없이 스케일링 하며 배포하고 연결하는 것은 어렵다.

  - 쿠버네티스는 분산 시스템을 탄력적으로 실행하기 위한 프레임워크를 제공한다. 스케줄러와 API 서버를 통해 새로운 오브젝트와 오퍼레이터를 다양한 프로덕션 요구에 맞게 커스터마이징 할 수 있다.

  - 쿠버네티스는 CI/CD 의 필수적인 부분이 될 수 있다. Helm, Jenkins 를 사용해 다양한 환경에서 소프트웨어를 테스트하고 배포하는 일관된 방법을 제공한다. 그리고 다양한 환경에서 소프트웨어를 배포하는 방법을 제공한다. 쿠버네티스는 업데이트와 롤백을 쉽게 하도록 컨테이너의 라이프 사이클과 인프라 리소스에 연결을 다룬다.

### 1-2. 쿠버네티스의 구성
  - 전통적으로 모노톨릭한 어플리케이션이 전용 서버에 배포되었다. 트래픽이 증가하면 어플리케이션은 수정되고 더 큰 리소스를 가진 전용 서버로 옮겼다. 트래픽을 처리하기 위한 많은 수정이 어플리케이션에 되었다.

  - 요즘은 큰 서버를 사용하는 대신 쿠버네티스를 활용해 작은 서버 여러 개를 배포한다. 서버에 replicas 로 불리는 여러 마이크로 서비스 형태로 배포한다. 결합도가 노은 httpd 데몬을 여러 개 가진 아피치 서버 대신 서로의 존재를 모르는 nginx 서버가 자주 사용된다.

  - MSA 구조를 위해 서비스와 API 호출을 사용한다. 서비스는 어플리케이션에서 다른 어플리케이션으로 트래픽을 연결하고 IP 나 다른 정보를 다룬다. 서비스는 죽게 되면 다른 서비스로 대체되어야 한다.

### 1-3. 쿠버네티스의 도전 과제
  - 컨테이너(도커)는 개발자가 컨테이너 이미지를 쉽게 만들고 레지스트리를 사용해 공유하고 관리하도록 한다.

  - 그러나 컨테이너를 마이크로 서비스 원리로 스케일링하고 분산 어플리케이션 구조를 짜는 것은 여전히 어렵다.

  - CI 파이프라인으로 컨테이너 이미지를 만들고 테스트해 검증해야 한다. 그리고 컨테이너를 실행하기 위한 클러스터가 필요하다. 또한 컨테이너를 실행하고 다운 되었을 때 복구할 시스템이 필요하다. 뿐만 아니라 롤백하거나 업데이트도 가능해야한다.

  - 모든 기능들은 유연하고 스케일링 가능해야 하며 네트워크와 스토리지를 쉽게 관리할 수 있어야 한다. 워커 노드에 컨테이너가 실행되면 네트워크는 리소스와 다른 컨테이너에 연결되어야 한다. 그리고 스토리지를 유지, 재사용하는 원활한 방법을 제공해야 한다.

### 1-4. Borg
  - 구글은 자신들이 제공하는 어플리케이션을 관리하기 위한 내부 시스템인 Borg 를 15년간 운영한 경험을 통해 쿠버네티스를 만들었다.

### 1-5 쿠버네티스 구조
![components-of-kubernetes](https://user-images.githubusercontent.com/13375810/158292653-d2268ca4-1aa4-4ed8-ba8e-a0ae025ec4ac.svg)

  - 쿠버네티스를 배포하면 클러스터를 얻는다.

  - 쿠버네티스 클러스터는 컨테이너화된 애플리케이션을 실행하는 워커 노드를 포함한다. 모든 클러스터는 최소 한 개의 워커 노드를 가진다. 워커 노드는 애플리케이션의 구성요소인 파드를 호스트한다. 

  - 컨트롤 플레인 노드는 워커 노드와 클러스터 내 파드를 관리한다. CP 노드는 API 서버, 스케줄러, 다양한 기능 그리고 클러스트의 상태와 컨테이너와 네트워크 설정 등의 데이터를 저장할 저장소를 가진다.

  - kubectl 이라는 명령어로 CP 노드의 API 서버에 명령을 내릴 수 있다.

  - kube-scheduler 는 API 요청을 확인하고 새로운 컨테이너를 스케줄해 실행한다.

  - 클러스터 내 각 노드들은 kubelet, kube-proxy 두 개의 컨테이너를 기본으로 실행한다. kueblet 은 컨테이너의 컨테이너 설정, 필요한 리소스 다운로드 및 관리 그리고 컨테이너 엔진 동작을 위해 스펙 정보를 받는다. kube-proxy 는 컨테이너를 네트워크로 드러내기 위한 방화벽 정책, 네트워크 설정을 관리한다.

  - 쿠버네티스에서 컨테이너를 동작, 관리하는 과정은 이벤트를 통해 동작한다.

### 1-6. 용어
  - 컨테이너는 개별적으로 관리되지 않는다. 컨테이너는 **파드**라 불리는 객체의 일부분이다. 파드는 IP 주소와 스토리지, 네임 스페이스를 공유하는 한 개 이상의 컨테이너로 구성되어 있다. 일반적으로 한 파드는 한 개의 컨테이너를 가진다.

  - **오케스트레이션**은 컨테이너를 배포, 확장하고 관리를 자동화 해주는 도구이다. 오케스트레이션은 **오퍼레이터**(**컨트롤러**)로 관리된다. 

  - **디플로이먼트** 는 로컬 상태가 없는 파드를 실행해 복제된 애플리케이션을 관리하는 API 오브젝트이다.

  - **레플리카셋**은 같은 스펙 정보로 여러 파드를 배포한 오퍼레이터이다.

  - **데몬셋(DaemonSet)** 은 모든 노드에 1개 씩 생성되고 노드가 추가되면 자동으로 이미지를 추가해 준다. 주로 로그, 모니터링, APM 등이 사용된다.

  - **스테이트풀셋(StatefulSet)** 파드들을 특정한 순서로 배포할 때 사용한다.

  - **레이블** 오브젝트를 식별하기 위한 태그이다. 오브젝트의 메타데이터 중 하나이다.

  - **어노테이션** 오브젝트를 식별 하는데 사용할 수 없다. 오브젝트에 메타데이터를 첨부할 때 사용하는 키-밸류 쌍이다.

  - **네임스페이스**는 쿠버네티스에서 하나의 클러스터 내에 리소스 그룹의 격리를 지원하기 위해 사용하는 추상적인 개념이다.

### 1-7. Control Plane Node

#### 1-7-1. kube-apiserver

#### 1-7-2. kube-scheduler

#### 1-7-3. Etcd Database

#### 1-7-4. 그 외

### 1-8. Worker Nodes

#### 1-8-1. kubelet

#### 1-8-2. kube-proxy

### 1-9. Pods

### 1-10. Services

### 1-11. Operators

### 1-12. Single IP per Pod

### 1-13. Networking setup

### 1-14. CNI Network 설정 파일

### 1-15. Pod to Pod 통신

