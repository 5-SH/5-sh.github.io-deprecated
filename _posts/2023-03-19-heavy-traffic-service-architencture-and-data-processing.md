---
layout: post
title: 4천만 MAU 를 지탱하는 서비스 설계와 데이터 처리 기술 강의 메모
date: 2023-03-19 20:30:00 + 0900
categories: Architecture
ref: DB, MAU, Service, Sharding, Architecture, Transaction
---

# 4천만 MAU 를 지탱하는 서비스 설계와 데이터 처리 기술 강의 메모

## 1. 대규모 서비스에서 발생하는 기술적 이슈 및 장애 사례
### 1-1. IT 서비스 혁신 = 비즈니스 모델의 혁신 ∋ 기술의 혁신
```
{기술 발전}이나 {소비자 욕구 변화}에 따라 혁신적인 {제품 또는 서비스}를 제공
aws - {가상화 기술 발전}과 {합리적 소비 확산}에 따라 혁신적인 {컴퓨팅 클라우드 서비스}를 제공
	-> 가상화 컴퓨팅 파워를 온라인 pay-per-use 방식으로 유통해 글로벌 서버 시장 장악
여기어떄 - {위치 기반 기술}과 {온라인 예약 확산}에 따라 혁신적인 {숙박, 레저 서비스}를 제공
	-> 위치 기반 기술을 사용해 사용자에 인접한 객실 상품을 유통해 숙박 예약 시장 장악
그런데 인터넷 스케일(인터넷 고객 트래픽)을 만나면,
	{기술 발전} - 확장성이 없는 디자인 ...
	{소비자 욕구 변화} - Push 발소에 따른 먹통, 빈번한 예약장애, 매출 분석의 불편함 ...
	{제품 또는 서비스} - 느린 앱 성능
	-> 숙박 예약 시장 장악 실패
	이런 현상을 "기술 부채" 라고 함
```	
### 1-2. 기술부채가 야기하는 문제들
```
기능 요구사항은 통과하는데 뭔가 잘못 짜여진 코드가 관리가 안될 떄까지 계속 불어나는 것
- 속도
	스프린트 당 처리되는 Task 수가 크게 감소
	-> 생산성 저하
- 스트레스
	개발팀의 일상적인 스트레스
	-> 잦은 퇴사
- 프로덕션
	수정 후에도 문제가 계속 발생
	-> 브랜드 이미지 실추
- 품질 
	릴리스 당 버그 수가 빠르게 증가
	-> 서비스 품질 저하
```
### 1-3. 기술 부채의 경고 징후
```		
너무 데이터베이스에 의존적인 경우 절망적인 쿼리가 서서히 자란다
개발 부서가 시장 요구 사항(APIs)과 빈번희 변화하는 사업 요구사항(Back Office)을 들어주려다 보니 발생함
예시
	예약 내역 테이블
	요구사항) 관리툴에서 지난 4년간 매출을 월 단위로 볼수 있게 해주세요.
	Table: reservationTable / 예약 내역 테이블 4년간 예약 건수가 1억 5천건
	[Reserve ID	|	Cust ID	|	Payment	|	Item ID	|	Date]
	단일 쿼리로 추출 시)
		SELECT date_format(date, '%M-%Y') as sdate, sum(payment) as 'netsales'
		FROM reservationTable
		WHERE year(sdate) = year('2016-01-01')
		GROUP BY year(sdate), month(sdate)
		ORDER BY year(sdate), month(sdate)
		-> Payment, Date 컬럼 풀스캔 해야함
		-> 쿼리 수행 시간은 1s 내로 떨어지기 어려움
			data[][] = {
				{ 0, 1 },
				{ 1, 4 },
				{ 0, 2 },
				{ 2, 3 }
			}
			
			1) Group By 
				Map<Integer, List<Integer>> = {
					{ 0, { 1, 2 }},
					{ 1, { 4 }},
					{ 2, { 3 }}
				}
			
			2) Summation
				Output[][] output;
				Map.forEatch((k, v) -> {
					int sum = 0;
					v.forEach(e -> {
						sum += e;
					});
					output[k][0] = k;
					output[k][1] = sum;
				});
				
				output:
					{ 0, 3 },
					{ 1, 4 },
					{ 2, 3 }
			
			3) Sort
	
			복잡도)
				공간 복잡도: 15 * 10^7 * 4 bytes(Payment) * 10 bytes(Date) = 6GB
				시간 복잡도: O(NM)(Summation) + O(KlogK)(Sort)
				-> 1s 내에 해결할 수 있는 쿼리가 아님. 몇 십분이 걸릴 수 있다
	해결 방법)
		느린 쿼리를 새벽마다 배치로 돌리고 쿼리 결과를 테이블에 담는다.
		날짜를 기준으로 해당 월의 매출의 집계를 계산해서 결과를 결과 테이블에 추가한다.
			[MM	|	SUM], 4 * 12 row
		월 단위 매출 조회는 결과 테이블을 대상으로 한다.
		-> Materialized View 방식이라고 한다. 일종의 캐시 방식
	
	한계점)
		배치 쿼리가 도는 동안, 결제 대금 취소 또는 재결제, 즉 DELETE 나 UPDATE 처리가 동시에 일어나면?
		조회한 매출 결과가 실제 결과와 약간 다를 수 있다. 
		더 큰 문제는 예약 내역 테이블이 다른 테이블과 심오하게 관계를 맺고 있거나 너무 많은 배치 쿼리들이 돌아가고 있는 것이다.
			-> 기술부채, 알 수 없는 곳에서 문제가 터지고 관리가 안된다.
어떻게 극복할 수 있나?
		문제				|		원인			
	서비스 장애와 성능 이슈			|	알고리즘과 자료구조 역량
	트래픽 대응 및 유지보수의 어려움		|	확장성 있는 설계, 소프트웨어 디자인 역량
	제품 품질을 위한 매뉴얼 운영 인력의 증가	|	사람 대신 기계, 데이터 활용 역량
```

## 2. 확장성 있는 시스템 설계와 소프트웨어 디자인이란?

### 2-1. 확장성과 안정성 있는 서비스 시스템 설계 패턴
```
yahoo 구조
	client						server					DB
	http://yahoo.com		-->		Apache + Perl CGI		61.72.103.108
	DNS lookup 61.72.103.24				61.72.103.24
	
	이 구조에서 웹서버에 장애 발생 시 모든 서비스가 중단됨.
	DB 에서 장애가 나도 똑같이 모든 서비스가 중단됨.
	-> 서비스 안정성, 확장성이 떨어진다. 단일 장애 구간(Single Point of Failure)
	
	아래 구조로 단일 장애 구간 해소
	client			L4				server				DB
				요청		\/	Apache + Per CGI #1		\/	Primary DB
				분산		/\	Apache + Per CGI #2		/\	Secondary DB
					
	웹서버나 DB 에 장애가 나도 서비스는 살아 있다.
```

```
확장성이란?
	Server-level Scalability
		서버 측 요청 수 증가에 따라 서버 확장이 용이한가?
			소프트웨어 스택 선정
			데이터베이스 설계
			시스템 아키텍처
			배포 관리
	Code-level Scalability
		새로운 요구사항에 대해 코드 변경이 용이한가?
			언어 선정
			테이블 설계
			디자인 패턴
			버전 관리
```

```
웹서버는 확장이 용이하지만 DB 는 확장이 어렵다.
	네트워크로 연결된 공유 스토리지를 활용하기도 한다
		DB Instance #1	\ 		
				 >	SAN Storage
		DB Instance #2	/ 
		SAN Storage 는 SPOF 이지만 매우 고가의 장비라서 큰 장애를 만든 경력이 없다.
	웹서버의 확장이 용이한 이유
		서로 아무것도 공유하지 않는 구조이다(Stateless)
	데이터베이스의 확장이 어려운 이유
		데이터베이스는 공유 자원이고 데이터 관계의 복잡도 때문
```

```
요즘은 샤딩으로 트래픽을 분산함
	client		L4			server							DB
			요	\  /	Apache + Per CGI #1	--	H	\  /	Shard #1(A~D)
			청	 \/	Apache + Per CGI #2	--	A	 \/	Shard #2(E~O)
			분	 /\	Apache + Per CGI #3	--	S	 /\	Shard #3(P~U)
			산	/  \	Apache + Per CGI #4	--	H	/  \	Shard #4(V-Z)
	샤딩을 하고 각 샤드를 Active-StandBy 로 HA 구성을 해줘야 함				
	대다수의 인터넷 서비스가 가진 아키텍처
```

```
스트리밍이나 채팅 서버 같은 서비스는 L4 의 라운드로빈 방식으로 트래픽을 분산해도 로드밸런싱이 되지 않는다.
	계속 오랫동안 유지되는 트래픽이기 때문에 시간이 지나면 한 곳에 몰려 있을 수 있다.
```

### 2-2. 대규모 서비스에서 알고리즘과 자료구조의 중요성
```
내 주변에 청결한 객실을 보여주세요.
	-> 내 주변의 객실을 검색하라 -> 2차 평면에서 거리 계산 문제
		int[][] point = {{3, 3}, {5,-1}, {-2, 4}}
		1. 유클리드 거리 계산
		2. 원점으로부터 거리 순으로 정렬
		3. 상위 K 개 출력
	정렬 문제
					1천 개		1백만 개		10억 개
		Mergesort(NlogN)	즉시		1초		18분	
		Quicksort(NlogN)	즉시		0.3초		6분
		모텔이 1백만 개고 모텔 별로 객실이 10개가 되면 10 * 1백만을 정력해야 하므로 매우 무거운 계산이다.
	구면 코사인 법칙
		원점: (37, 122)
		SELECT	id, (3959 * acos(cos(radians(37)) * cos(radians*(lat)) * cos(radians(long)-radians(-122) + sin(radians(37)) * sin(radians(lat)))) AS distance
		FROM	myTable
		HAVING	distance < 10
		ORDER BY	distance;
		
		id		name 		Ion			lat
		1		Mark		-76.316528	40.036027
		2		John		-95-995102	4125167
		3		Paul		-82.337036	29.645095
		4		Dave		-82.337034	29.635096
		6		Chris		-76.316528	40.036027
		
		if 10^5 rows * 8 bytes * 8bytes = 64MB 크기의 메모리가 필요하고
		거리 계산 O(n) * 거리 정렬 O(nlogn) 이 걸린다.
		-> 1초 이내 계산할 수 없게 된다.
		-> 여러 건의 요청이 들어오면 데이터베이스에 거리 계산과 정렬 연산 부하가 몰리게 된다.
		-> 분산 처리를 위해 순전히 DB 서버에 의존하지 않고 API 서버의 리소스를 활용하기 위해 DB 에서 좌표만 가져오고 계산은 API 서버에서 한다.
			API Server #1 (좌표 값을 받아와 계산)	\ 		
			API Server #2 (좌표 값을 받아와 계산)	 >	DB Server
			API Server #3 (좌표 값을 받아와 계산)	/
		
		Q, 정렬을 빠르게 하기 위해 Ion, lat 컬럼에 인덱스를 걸면 빨리지지 않을까?
			ORDER BY 구절에서 정렬 문제는 전체 데이터 SET 을 가지고 와야하기 때문에 인덱스와 관계가 없다.
			-> MySQL 는 정렬을 빠르게 하기 위한 공간 색인 같은 알고리즘을 지원하지 않고 B-tree 인덱싱만 제공한다.
```		

```
내 주변 택시 찾기
	택시처럼 위치가 수시로 변경된다면?
		공간 색인하는 시간이 있기 때문에 다른 고민이 추가로 필요하다.
```

```
안심번호 할당문제
	통신사로부터 10,000 개의 안심번호를 할당 받았을 때, 안심번호를 원하는 고객에게 할당해달라.
	
	SELECT id, telNum
	FROM myTable
	WHERE userID is null
	LIMIT 1;
	Then,
	UPDATE myTable
	SET userID = myID
	WHERE id = 3;
	id		telNum		lat
	1		1555-487	Null
	2		1585-5454	Paul
	3		1555-8874	Cris
	...
	10^3	1555-8711	Null
	-> 동시에 접근하는 경우, 경합(Race Condition) 문제가 발생한다.
		API 서버가 분산된 환경에서 USER1, USER2 가 동시에 요청을 하게 되면 동일한 레코드를 반환받고 경합 문제가 발생한다.
		API Server #1 (USER1) SELECT id, telNum ...	\ 		
		API Server #2 			 		 >	DB Server
		API Server #3 (UESR2) SELECT id, telNum ...	/
	-> 경합 문제를 해결하기 위해 lat 가 NULL 인 id 중 랜덤으로 아이디를 뽑는 방법이 있다.
		동시 접속자가 많아지면 중복이 생길 확률이 많아져 완벽하지 않고 간헐적으로 장애가 발생함
		SELECT id, telNum
		FROM myTable
		WHERE userID is null
		ORDER BY rand()
		LIMIT 1;
		Then,
		UPDATE myTable
		SET userID = myID
	-> 공유 자원에 대한 동시 접근 제어 처리 지식이 있어야 해결 가능
		Lock, Mutex 와 Semaphore 
		마이크로서비스 환경에서 여러 서비스들이 동시에 메인 DB 에 접근할 때
			마이크로서비스#1		마이크로서비스#2		락매니저		메인DB
				□──────────────────락 요청─────────────────>□
				□<─────────────────락 회신──────────────────□
							■─────락 요청──────>■
							■<────락 획득실패───■
				□────────────────────────레코드 수정──────────────────────>□
				□<────────────────────────수정 성공────────────────────────□
				□─────────────────락 해제─────────────────>□
```

```		
간단한 기능을 구현하더라도 알고리즘 내부 동작을 알고 모르고에 따라 구현의 성숙도, 품질, 생산성이 크게 달라질 수 있다.
```

### 2-3. 코드 유지보수성과 확장성을 높이는 디자인 패턴
```
확장성이란?
					서버 레벨				코드 레벨
	정의			서버 측 요청 수 증가에 따라		새로운 요구사항에 대해
				확장이 용이한가?				코드 변경이 용이한가?
	핵심문제			1. 소프트웨어 스택 선정			1. 언어 선정
				2. 데이터베이스 설계			2. 테이블 설계
				3. 시스템 아키텍처			3. 디자인 패턴
				4. 배포 관리				4. 버전 관리		
```		

```
프로그램 패러다임
	1) 절차적 프로그래밍
		명시된 입력을 받아서 순서대로 처리
		너무 복잡함
	2) 구조적 프로그래밍
		코드를 함수로 쪼갬(탑-다운)
		데이터 구조화가 너무 어려움
	3) 객체지향 프로그래밍
		데이터와 관련 코드를 결합한 작은 객체를 기본 단위로 큰 문제를 해결(바텀-업)
		역할 중심으로 문제를 Divide and conquer
		소프트웨어가 거대해지면서 복잡해지기 시작
	-> 디자인 패턴의 대두
```

```
디자인 패턴
	문제를 해결하기 위한 모범 사례의 일반화된 디자인 유형
사례1) 객체 합성
	객체합성 구조를 통해 확장성을 획득
	클라이언트는 인터페이스만 바라보고 사용
	실제 구현이 인터페이스 아래로 추상화 되기 때문에 새로운 기능을 개발해 추가해도 클라이언트에 수정이 필요 없음
	기능 추가로 인한 수정사항이 인터페이스 아래로 캡슐화 됨
```

```
의존성 주입
	객체지향 설계 패턴의 보조도구
	인터페이스와 구체 클래스의 관계를 런타임에 맺어준다.
간편결제 추가 도입 사례
	각 객체 모듈이 아래와 같이 개별적으로 개발되어 있다면,
		Client--------PayModule1(카드결제 모듈)------PG사
		    ├---------PayModule2(계좌이체 모듈)--------┤
		    ├---------PayModule3(가상계좌 모듈)--------┘
		    └---------PayModule4(간편결제 모듈)--------간편결제 업체-----PG사
		새로운 간편결제 모듈을 추가하기 어렵고 각 결제 모듈 구현 방법이 달라
		이슈 발생 시 개발한 사람만 대응할 수 있다.
	객체 합성과 의존성 주입을 도입하면,
		Client-----PayService-----PayModule1(카드결제 모듈)-----PG사
				 ├--------PayModule2(계좌이체 모듈)-----┤
				 ├--------PayModule3(가상계좌 모듈)-----┘
				 └--------PayModule4(간편결제 모듈)-----간편결제 업체-----PG사
		※ 구체 클래스 주입은 xml 같은 설정 파일로 빼둠
		PayService 인터페이스에 맞게 새로운 결제 모듈을 만들면 클라이언트 부분은 수정이 필요없고
		구현 방법과 히스토리를 알 필요 없어 이슈 발생 시 대응하기 쉽다.
```

```
논리적 아키텍처
	대규모의 소프트웨어 클래스를 패키지, 서브시스템 및 레이어로 조직화 한 것
```		

``` 
함수형 언어 모델
	함수형 언어 모델을 분산 병렬 컴퓨팅에 사용
	일급 함수의 조합을 통해 문제를 해결한다.
	함수 내에서 상태를 가지지 않아 동시성 문제가 발생하지 않는다.
	함수형 언어에는 디자인 패턴이 필요한가?
		함수형 프로그래밍은 객체지향 프로그래밍과 다릅니다.
		따라서 객체지향 디자인 패턴은 적용되지 않습니다.
		대신 함수형 프로그래밍 디자인 패턴은 있습니다.
			커링 패턴 : Function Composition. 함수를 인자로 받거나 결과로 반환하는 함수
				콜백도 커링 패턴의 일종이다.
```					

### 2-4. 데이터 모델과 트랜잭션 디자인
```
서버를 개발할 때 데이터 처리는 중요하다.
```

```
논리적 데이터 아키텍처
	데이터 스키마 또는 논리적 데이터 모델
		- 객체 기반의 개체-관계 ER(Entity-Relationship) 모델
		- 행 기반의 관계형(Relation) 모델
		- 중첩된 키, 값 쌍 다차원(NoSQL) 모델
```

```
ORM(Object Relational Mapping)
	관계형 데이터 모델을 OOP 의 Entitiy 형태로 매핑 시키는 방법
	객체지향에서의 상속 관계를 관계형 데이터베이스 모델로 매핑하는 다양한 방법이 있다.
	ORM 은 지속적인 서비스를 운영하고 소프트웨어를 개발, 배포하기 위해 사용한다.
	ORM 는 DB 와 SW 중간의 Persistence Layer 라고 한다.
		DBMS 에 대한 종속성이 줄어든다.
		재사용 및 유지보수가 쉽다.
		직관적인 코드로 볼 수 있다.
	대규모 서비스의 업데이트는 부분적으로 진행되는 경우가 많다. 따라서 데이터의 이전 버전과 새 버전을 동시에 사용할 수 있어야 한다.
		이런 문제를 ORM 은 최소화 할 수 있도록 지원한다.	
		데이터베이스와 관련된 선언문, 할당, 종료 등 statement 관련 코드들이 사라져 객체지향적인 코드만 남아 직관적이다.
```

```		
트랜잭션
	데이터베이스의 상태를 변화시키기 위해 수행하는 논리적 작업의 단위
	예를 들어, 페이스북에서 친구 요청을 수락할 때,
		transaction: {(1)나의 친구 목록에 추가함과 동시에(insert),
					(2) 상대방의 친구 요청 대기 상태를 수락으로(update)}
		그래서 트랜잭션은 원자성, 일관성, 독립성, 지속성을 지켜야 한다.
```

```
트랜잭션 인터페이스 디자인
	클라이언트(DB 서버에 요청하는 API 서버)에게 트랜잭션 존재를 알릴 것인지 말 것 인지가 가장 중요하다.
	트랜잭션을 명시해 시작과 끝을 제어할 수 있게 하거나
	추상 트랜잭션 메커니즘으로 숨겨 클라이언트가 신경쓰지 않게 개발할 수 있다.
```
