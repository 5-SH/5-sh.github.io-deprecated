---
layout: post
title: 스프링의 변천사 그리고 Java 9 과 Spring 5
date: 2022-05-23 17:00:00 + 0900
categories: Spring
ref: Spring, Java
---

# 스프링의 변천사 그리고 Java 9 과 Spring 5

## 1. 스프링의 특징
스프링을 지탱하는 세 가지 기술 IoC, DI, 서비스 추상화.     
스프링 기술과 도메인 논리를 분리하고 도메인 논리를 POJO 로 개발한다.

### 1-1. Dependency Injection
클라이언트가 요구하는 행동을 인터페이스로 설계한다.    
클라이언트는 구체적으로 구현된 행동을 외부에서 인터페이스를 통해 전달받는다.    
의존성 주입을 통해 클라이언트의 코드를 수정할 필요 없이 구체적인 행동을 추가하고 수정할 수 있어,    
유연하고 확장성이 좋은 애플리케이션을 개발할 수 있다.    

### 1-2. Inversion Of Control
애플리케이션에서 제공하는 서비스를 수행하기 위한 구체적인 행동들은 스프링 빈으로 제공된다.    
빈 객체들이 제공될 방법은 애플리케이션 컨텍스트 설정 메타정보에 작성되어 있고    
애플리케이션 컨텍스트는 빈 객체의 생성과 주입 그리고 라이프 사이클을 관리한다.    

오브젝트가 자신이 사용할 오브젝트를 스스로 선택하던 기존 방법과 다르게   
스프링은 애플리케이션 컨텍스트를 통해 사용할 오브젝트를 주입받는다.   
따라서 애플리케이션의 흐름이 프레임워크에 의해 관리된다.   

의존성 역전을 통해 자연스럽게 관심을 분리하고 책임을 나누고 유연하게 확장 가능한 구조로 만든다.
즉, 객체지향적인 서비스를 만들 수 있게 된다.

### 1-3. 서비스 추상화
애플리케이션은 비즈니스 논리를 구현한다. 비즈니스 논리는 애플리케이션 논리와 도메인 논리로 나눌 수 있다.    
애플리케이션 논리는 AOP, 인터셉터, 필터 또는 메일, 트랜잭션, 보안 등 스프링에서 추상화한 기능들이다.    
도메인 논리는 클라이언트에게 제공할 행동(서비스)들을 구현한 것이다.    

도메인 논리와 애플리케이션 논리가 한 곳에 구현되면 사용자의 요구사항이 바뀔 때,   
스프링에서 제공하는 기능이 바뀔 때 두 가지 관점에서 수정되게 된다.     
도메인 논리가 스프링 기술과 결합되기 때문에 클라이언트에게 제공할 행동들이 스프링 기술에 제약되게 된다.   

따라서 도메인 논리와 애플리케이션 논리를 구분해 구현하고 서비스 추상화 계층에서 결합한다.    
스프링에서 제공하는 기술과 도메인 기능 구현을 분리를 통해 서비스를 다양한 방식으로 제공할 수 있게 되고,
애플리케이션을 쉽게 수정하고 확장할 수 있게 된다.

### 1-4. POJO
스프링을 지탱하는 세 가지 기술들을 통해 애플리케이션을 POJO 로 개발할 수 있다.   
특정 기술과 환경에 종속되지 않고 객체지향적인 원리에 충실하게 개발되어    
유연하게 확장하고 수정이 가능한 애플리케이션을 만들 수 있다.    

POJO 로 개발된 코드는 테스트하기 쉽고 도메인 모델과 디자인 패턴을 쉽게 적용할 수 있다.    
스프링은 POJO 로 개발할 수 있도록 지원하는 프레임워크이다.

## 2. 스프링의 위기와 극복

### 2-1. 첫 번째 위기 
#### 과도한 기술로 복잡해진 코드(J2EE, EJB)
J2EE, EJB 규약을 통해 애플리케이션을 개발했다.    
J2EE, EJB 규약은 너무 복잡하고 많은 클래스를 상속하고 의존하도록 강제되어 있어    
좋은 객체지향 애플리케이션을 만들기 어렵게 되어 있었다.    
이 문제를 해결하기 위해 스프링은 IoC, DI, 서비스 추상화 기술을 도입해   
좋은 객체지향 애플리케이션을 개발할 수 있도록 했다.

```java
// EJB 에서만 동작하는 기술에 종속된 코드
public class Client {
  public callService() {
    Context jndiContext = getInitialContext();

    Object ref = jndiContext.look("MyserviceHomeRemote");
    MyServiceHomeRemote home = (MyServiceHomeRemote) PortableRemoteObject.narrow(ref, MyServiceHomeRemoate.class);

    MyServiceRemote myService = home.create();

    myService.service()
  }
}
```

### 2-2. 두 번째 위기
#### 자바 언어에 대한 발전 요구와 호환성(.NET)
새롭게 개발된 닷넷과 같은 언어에 비해 제공하는 기능이 부족해 자바 언어(~1.4 버전)의 발전이 요구되었다.   
자바는 이전 버전과의 호환성을 지키면서 제네릭스 애노테이션 등 다양한 기능을 추가한 1.5 버전을 개발했다.    
즉, 이전 버전으로 작성된 바이트 코드를 다시 컴파일 할 필요 없이 실행할 수 있다.    

### 2-3. 세 번째 위기
#### 간경한 코드와 관례로 무장한 기술의 습격(루비, 레일즈)
애노테이션 기반 프로그래밍과 영리한 설정으로 간결하게 애플리케이션을 만들 수 있는 언어와 프레임워크가 등장했다.   
설정을 최소화 하고 관례를 우선한 루비와 레일즈는 15분 만에 블로그를 만들 수 있었다.   

스프링은 이 문제를 애노테이션 기반의 메타프로그래밍과      
영리한 디폴트로 무장한 관례를 적극 도입한 스프링부트를 통해 극복했다.    

```java
@Controller
public class HelloWorldController {
  @RequestMapping("/helloWorld")
  public String helloWorld(Model module) {
    model.addAttribute("message", "Hello World!");
    return "helloWorld";
  }
}
```

### 2-4. 네 번째 위기
#### 함수형 프로그래밍과 비동기 논 블로킹 개발의 도전
스칼라, 자바스크립트 같은 함수형 언어와 비동기 논블로킹에 최적화된 Node.js 의 등장했다.   
그리고 대용량 비동기 분산 시스템 개발에 적합한 함수형 프로그래밍 필요성이 대두 되었다.   

함수형 프로그래밍 스타일의 Java 8 과 비동기 논블록킹을 지원하는 서블릿을 사용하는 스프링이 등장했다.   
Java 8 은 함수형 인터페이스와 람다식, 메소드 레퍼런스, 디폴트 메소드, CompletableFuture 을 지원한다.   
Servlet 3.0 은 비동기 웹 요청 처리 방식을 지원하고 비동기 논블로킹 IO 를 지원한다.


## 3. 새로운 변화

### 3-1. 자바 9


### 3-2. 스프링 5